---
title: Tool streaming
meta:
  title: Tool streaming | Tiptap Content AI
  description: Add real-time tool streaming to your AI agent chatbot to see changes as they happen.
  category: Content AI
---

import { Callout } from '@/components/ui/Callout'
import { CodeDemo } from '@/components/CodeDemo'

<Callout title="Continuation from the AI agent chatbot guide" variant="info">
  This guide continues the [AI agent chatbot
  guide](/content-ai/capabilities/ai-toolkit/guides/ai-agent-chatbot). Read it first.
</Callout>

Instead of using `executeTool`, you can use `streamTool` to see changes in real-time as the AI generates them. This creates a more engaging user experience where users can watch the AI make changes incrementally.

## Key changes

The main difference is that instead of calling `executeTool` when the tool call is complete, you call `streamTool` both during streaming and when the tool call is finished.

### 1. Update the onToolCall handler

Replace the `executeTool` call with `streamTool` and set `hasFinished: true` when the tool call is complete:

```tsx
async onToolCall({ toolCall }) {
  const editor = editorRef.current
  if (!editor) return

  const { toolName, input, toolCallId } = toolCall

  // Use the AI Toolkit to stream the tool
  const toolkit = getAiToolkit(editor)
  const result = toolkit.streamTool({
    toolCallId,
    toolName,
    input,
    currentChunk: currentChunk.current,
    // This parameter indicates that the tool streaming is complete
    hasFinished: true,
  })

  currentChunk.current = result.currentChunk

  addToolResult({ tool: toolName, toolCallId, output: result.output })
},
```

### 2. Add streaming updates

Add a `useEffect` hook to handle streaming updates while the tool call is in progress:

```tsx
// While the tool streaming is in progress, we need to update the document
// as the tool input changes
useEffect(() => {
  if (!editor) return

  // Find the last message
  const lastMessage = messages[messages.length - 1]
  if (!lastMessage) return

  // Find the last tool that the AI has just called
  const toolCallParts = lastMessage.parts.filter((p) => p.type.startsWith('tool-')) ?? []
  const lastToolCall = toolCallParts[toolCallParts.length - 1]
  if (!lastToolCall) return

  // Get the tool call data
  interface ToolStreamingPart {
    input: unknown
    state: string
    toolCallId: string
    type: string
  }
  const part = lastToolCall as ToolStreamingPart
  if (!(part.state === 'input-streaming')) return
  const toolName = part.type.replace('tool-', '')

  // Apply the tool call to the document, while it is streaming
  const toolkit = getAiToolkit(editor)
  toolkit.streamTool({
    toolCallId: part.toolCallId,
    toolName,
    input: part.input,
    currentChunk: currentChunk.current,
  })
}, [addToolResult, editor, messages])
```

## Complete implementation

Here's the complete updated component with tool streaming:

```tsx
'use client'

import { DefaultChatTransport, lastAssistantMessageIsCompleteWithToolCalls } from 'ai'
import { useChat } from '@ai-sdk/react'
import { EditorContent, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import { useEffect, useRef, useState } from 'react'
import { AiToolkit, getAiToolkit } from '@tiptap-pro/ai-toolkit'

export default function Page() {
  const editor = useEditor({
    immediatelyRender: false,
    extensions: [StarterKit, AiToolkit],
    content: `<h1>AI Agent Demo</h1><p>Ask the AI to improve this.</p>`,
  })

  // Fixes issue: https://github.com/vercel/ai/issues/8148
  const editorRef = useRef(editor)
  editorRef.current = editor

  // The AI Agent reads the document in chunks. This variable tracks of the current chunk
  // that the AI Agent is reading.
  const currentChunk = useRef(0)

  const { messages, sendMessage, addToolResult } = useChat({
    transport: new DefaultChatTransport({ api: '/api/chat' }),
    sendAutomaticallyWhen: lastAssistantMessageIsCompleteWithToolCalls,
    async onToolCall({ toolCall }) {
      const editor = editorRef.current
      if (!editor) return

      const { toolName, input, toolCallId } = toolCall

      // When the tool streaming is complete, we need to apply the tool call to the document
      // Use the AI Toolkit to execute the tool
      const toolkit = getAiToolkit(editor)
      const result = toolkit.streamTool({
        toolCallId,
        toolName,
        input,
        currentChunk: currentChunk.current,
        // This parameter indicates that the tool streaming is complete
        hasFinished: true,
      })

      currentChunk.current = result.currentChunk

      addToolResult({ tool: toolName, toolCallId, output: result.output })
    },
  })

  const [input, setInput] = useState(
    'Insert, at the end of the document, a long story with 10 paragraphs about Tiptap',
  )

  // While the tool streaming is in progress, we need to update the document
  // as the tool input changes
  useEffect(() => {
    if (!editor) return

    // Find the last message
    const lastMessage = messages[messages.length - 1]
    if (!lastMessage) return

    // Find the last tool that the AI has just called
    const toolCallParts = lastMessage.parts.filter((p) => p.type.startsWith('tool-')) ?? []
    const lastToolCall = toolCallParts[toolCallParts.length - 1]
    if (!lastToolCall) return

    // Get the tool call data
    interface ToolStreamingPart {
      input: unknown
      state: string
      toolCallId: string
      type: string
    }
    const part = lastToolCall as ToolStreamingPart
    if (!(part.state === 'input-streaming')) return
    const toolName = part.type.replace('tool-', '')

    // Apply the tool call to the document, while it is streaming
    const toolkit = getAiToolkit(editor)
    toolkit.streamTool({
      toolCallId: part.toolCallId,
      toolName,
      input: part.input,
      currentChunk: currentChunk.current,
    })
  }, [addToolResult, editor, messages])

  if (!editor) return null

  return (
    <div>
      <EditorContent editor={editor} />
      {messages?.map((message) => (
        <div key={message.id} style={{ whiteSpace: 'pre-wrap' }}>
          <strong>{message.role}</strong>
          <br />
          {message.parts
            .filter((p) => p.type === 'text')
            .map((p) => p.text)
            .join('\n')}
        </div>
      ))}
      <form
        onSubmit={(e) => {
          e.preventDefault()
          sendMessage({ text: input })
          setInput('')
        }}
      >
        <input value={input} onChange={(e) => setInput(e.target.value)} />
      </form>
    </div>
  )
}
```

## End result

With tool streaming, users can see changes happening in real-time as the AI generates them. Try it out:

<CodeDemo path="" isScrollable src="https://ai-toolkit-demos.vercel.app/tool-streaming" />

See the [source code on GitHub](https://github.com/ueberdosis/ai-toolkit-demos).

## Next steps

Combine tool streaming with change review for the best user experience. See the [review changes guide](/content-ai/capabilities/ai-toolkit/guides/review-changes) to learn how to let users preview and approve changes before they're applied.
