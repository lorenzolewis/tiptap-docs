---
title: Markdown Utilities
tags:
  - type: beta
meta:
  title: Markdown Utilities | Tiptap Editor Docs
  description: Use built-in utilities from @tiptap/core for standard markdown patterns. Learn more in our docs!
  category: Editor
---

## Block Utilities

### `createBlockMarkdownSpec`

Creates a complete markdown specification for block-level nodes using Pandoc-style syntax (`:::blockName`).

#### Syntax

```markdown
:::blockName {attributes}

Content goes here
Can be **multiple** paragraphs

:::
```

#### Usage

```typescript
import { Node } from '@tiptap/core'
import { createBlockMarkdownSpec } from '@tiptap/core'

const Callout = Node.create({
  name: 'callout',

  group: 'block',
  content: 'block+',

  addAttributes() {
    return {
      type: { default: 'info' },
      title: { default: null },
    }
  },

  parseHTML() {
    return [{ tag: 'div[data-callout]' }]
  },

  renderHTML({ node }) {
    return ['div', { 'data-callout': node.attrs.type }, 0]
  },

  // Use the utility to generate markdown support
  markdown: createBlockMarkdownSpec({
    nodeName: 'callout',
    defaultAttributes: { type: 'info' },
    allowedAttributes: ['type', 'title'],
    content: 'block', // Allow nested block content
  }),
})
```

#### Options

| Option                | Type                  | Default    | Description                |
| --------------------- | --------------------- | ---------- | -------------------------- |
| `nodeName`            | `string`              | _required_ | Tiptap node name           |
| `name`                | `string`              | `nodeName` | Markdown syntax name       |
| `content`             | `'block' \| 'inline'` | `'block'`  | Content type               |
| `defaultAttributes`   | `Object`              | `{}`       | Default attrs when parsing |
| `allowedAttributes`   | `string[]`            | all        | Whitelist for rendering    |
| `getContent`          | `(token) => string`   | auto       | Custom content extraction  |
| `parseAttributes`     | `(str) => Object`     | auto       | Custom attribute parser    |
| `serializeAttributes` | `(attrs) => string`   | auto       | Custom serializer          |

#### Example Markdown

```markdown
:::callout {type="warning" title="Important"}

This is a warning callout with a title.

It can contain multiple paragraphs and **formatting**.

:::

:::note

Simple note without attributes.

:::
```

---

### `createAtomBlockMarkdownSpec`

Creates a markdown specification for atomic (self-closing) block nodes using Pandoc syntax.

#### Syntax

```markdown
:::nodeName {attributes}
```

No closing tag, no content. Perfect for embeds, images, horizontal rules, etc.

#### Usage

```typescript
import { Node } from '@tiptap/core'
import { createAtomBlockMarkdownSpec } from '@tiptap/core'

const Youtube = Node.create({
  name: 'youtube',

  group: 'block',
  atom: true,

  addAttributes() {
    return {
      src: { default: null },
      start: { default: 0 },
      width: { default: 640 },
      height: { default: 480 },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'iframe[src*="youtube.com"]',
        getAttrs: dom => ({
          src: dom.getAttribute('src'),
        }),
      },
    ]
  },

  renderHTML({ node }) {
    return ['iframe', { src: node.attrs.src }, 0]
  },

  // Use the utility for atomic block markdown
  markdown: createAtomBlockMarkdownSpec({
    nodeName: 'youtube',
    requiredAttributes: ['src'], // Must have src attribute
    defaultAttributes: { start: 0 },
    allowedAttributes: ['src', 'start', 'width', 'height'],
  }),
})
```

#### Options

| Option                | Type                | Default    | Description                    |
| --------------------- | ------------------- | ---------- | ------------------------------ |
| `nodeName`            | `string`            | _required_ | Tiptap node name               |
| `name`                | `string`            | `nodeName` | Markdown syntax name           |
| `requiredAttributes`  | `string[]`          | `[]`       | Required attrs for valid parse |
| `defaultAttributes`   | `Object`            | `{}`       | Default attrs when parsing     |
| `allowedAttributes`   | `string[]`          | all        | Whitelist for rendering        |
| `parseAttributes`     | `(str) => Object`   | auto       | Custom attribute parser        |
| `serializeAttributes` | `(attrs) => string` | auto       | Custom serializer              |

#### Example Markdown

```markdown
:::youtube {src="https://youtube.com/watch?v=dQw4w9WgXcQ" start="30"}

:::image {src="photo.jpg" alt="A beautiful photo" width="800"}

:::hr
```

---

## Inline Utilities

### `createInlineMarkdownSpec`

Creates a markdown specification for inline nodes using shortcode syntax (`[nodeName]`).

#### Syntax

```markdown
<!-- Self-closing -->

[nodeName attribute="value" other="data"]

<!-- With content -->

[nodeName attribute="value"]content[/nodeName]
```

#### Usage - Self-Closing

```typescript
import { Node } from '@tiptap/core'
import { createInlineMarkdownSpec } from '@tiptap/core'

const Mention = Node.create({
  name: 'mention',

  group: 'inline',
  inline: true,
  atom: true,

  addAttributes() {
    return {
      id: { default: null },
      label: { default: null },
    }
  },

  parseHTML() {
    return [{ tag: 'span[data-mention]' }]
  },

  renderHTML({ node }) {
    return ['span', { 'data-mention': node.attrs.id }, `@${node.attrs.label}`]
  },

  // Use the utility for self-closing inline markdown
  markdown: createInlineMarkdownSpec({
    nodeName: 'mention',
    selfClosing: true,
    allowedAttributes: ['id', 'label'],
  }),
})
```

#### Usage - With Content

```typescript
const Highlight = Node.create({
  name: 'highlight',

  group: 'inline',
  content: 'inline*',

  addAttributes() {
    return {
      color: { default: 'yellow' },
    }
  },

  parseHTML() {
    return [{ tag: 'mark' }]
  },

  renderHTML({ node }) {
    return ['mark', { 'data-color': node.attrs.color }, 0]
  },

  // Use the utility for inline markdown with content
  markdown: createInlineMarkdownSpec({
    nodeName: 'highlight',
    selfClosing: false, // Has content
    allowedAttributes: ['color'],
  }),
})
```

#### Options

| Option                | Type                | Default    | Description                |
| --------------------- | ------------------- | ---------- | -------------------------- |
| `nodeName`            | `string`            | _required_ | Tiptap node name           |
| `name`                | `string`            | `nodeName` | Shortcode name             |
| `selfClosing`         | `boolean`           | `false`    | Has no content             |
| `defaultAttributes`   | `Object`            | `{}`       | Default attrs when parsing |
| `allowedAttributes`   | `string[]`          | all        | Whitelist for rendering    |
| `getContent`          | `(node) => string`  | auto       | Custom content extraction  |
| `parseAttributes`     | `(str) => Object`   | auto       | Custom attribute parser    |
| `serializeAttributes` | `(attrs) => string` | auto       | Custom serializer          |

#### Example Markdown

```markdown
<!-- Mentions -->

Hey [mention id="user123" label="John"]!

<!-- Emoji -->

Party time [emoji name="party_popper"]!

<!-- Highlight with content -->

This is [highlight color="yellow"]important text[/highlight] to read.
```

---

## Helper Utilities

### `parseAttributes`

Parses Pandoc-style attribute strings into JavaScript objects.

#### Supported Formats

```typescript
import { parseAttributes } from '@tiptap/core'

// Classes (prefix with .)
parseAttributes('.btn .primary')
// → { class: 'btn primary' }

// IDs (prefix with #)
parseAttributes('#submit')
// → { id: 'submit' }

// Key-value pairs (quoted values)
parseAttributes('type="button" disabled')
// → { type: 'button', disabled: true }

// Combined
parseAttributes('.btn #submit type="button" disabled')
// → { class: 'btn', id: 'submit', type: 'button', disabled: true }

// Complex example
parseAttributes('.card .elevated #main-card title="My Card" data-id="123" visible')
// → {
//   class: 'card elevated',
//   id: 'main-card',
//   title: 'My Card',
//   'data-id': '123',
//   visible: true
// }
```

#### Usage

```typescript
import { parseAttributes } from '@tiptap/core'

const attrString = '.highlight #section-1 color="yellow" bold'
const attrs = parseAttributes(attrString)

console.log(attrs)
// {
//   class: 'highlight',
//   id: 'section-1',
//   color: 'yellow',
//   bold: true
// }
```

---

### `serializeAttributes`

Serializes JavaScript objects back to Pandoc-style attribute strings.

#### Usage

```typescript
import { serializeAttributes } from '@tiptap/core'

const attrs = {
  class: 'btn primary',
  id: 'submit',
  type: 'button',
  disabled: true,
  'data-value': '123',
}

const attrString = serializeAttributes(attrs)
console.log(attrString)
// .btn.primary #submit disabled type="button" data-value="123"
```

#### Rules

- Classes are prefixed with `.` and space-separated
- IDs are prefixed with `#`
- Boolean `true` values become standalone attributes
- String values are quoted with `"`
- Null/undefined values are omitted

---

### `parseIndentedBlocks`

Advanced utility for parsing hierarchical indented blocks (lists, task lists, etc.).

#### When to Use

Use this when you need to parse markdown with:

- Nested items based on indentation
- Hierarchical structure (not flat)
- Custom block patterns

#### Usage Example - Task List

```typescript
import { parseIndentedBlocks } from '@tiptap/core'

const src = `
- [ ] Task 1
  - [x] Subtask 1.1
  - [ ] Subtask 1.2
- [x] Task 2
`

const result = parseIndentedBlocks(
  src,
  {
    // Pattern to match task items
    itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,

    // Extract data from matched line
    extractItemData: match => ({
      indentLevel: match[1].length,
      mainContent: match[4],
      checked: match[3].toLowerCase() === 'x',
    }),

    // Create the final token
    createToken: (data, nestedTokens) => ({
      type: 'taskItem',
      checked: data.checked,
      text: data.mainContent,
      nestedTokens, // Nested items
    }),
  },
  lexer,
)

console.log(result)
// {
//   items: [
//     {
//       type: 'taskItem',
//       checked: false,
//       text: 'Task 1',
//       nestedTokens: [
//         { type: 'taskItem', checked: true, text: 'Subtask 1.1' },
//         { type: 'taskItem', checked: false, text: 'Subtask 1.2' }
//       ]
//     },
//     {
//       type: 'taskItem',
//       checked: true,
//       text: 'Task 2'
//     }
//   ]
// }
```

#### Options

```typescript
interface BlockParserConfig {
  itemPattern: RegExp // Pattern to match items
  extractItemData: (match) => {
    mainContent: string
    indentLevel: number
    [key: string]: any
  }
  createToken: (data, nestedTokens?) => ParsedBlock
  baseIndentSize?: number // Base indent (default: 2)
  customNestedParser?: (src) => any[] // Custom nested parser
}
```

---

### `renderNestedMarkdownContent`

Utility for rendering nodes with nested content, properly indenting child elements.

#### When to Use

Use this when rendering:

- List items with nested content
- Blockquotes with nested elements
- Task items with subtasks
- Any node with a prefix and nested children

#### Usage Example - List Item

```typescript
import { renderNestedMarkdownContent } from '@tiptap/core'

const ListItem = Node.create({
  name: 'listItem',

  markdown: {
    render: (node, h) => {
      // Static prefix
      return renderNestedMarkdownContent(node, h, '- ')
    },
  },
})
```

#### Usage Example - Task Item

```typescript
const TaskItem = Node.create({
  name: 'taskItem',

  markdown: {
    render: (node, h) => {
      // Dynamic prefix based on checked state
      const prefix = `- [${node.attrs?.checked ? 'x' : ' '}] `
      return renderNestedMarkdownContent(node, h, prefix)
    },
  },
})
```

#### Usage Example - Context-Based Prefix

```typescript
const ListItem = Node.create({
  name: 'listItem',

  markdown: {
    render: (node, h, ctx) => {
      // Prefix changes based on parent type
      return renderNestedMarkdownContent(
        node,
        h,
        ctx => {
          if (ctx.parentType === 'orderedList') {
            return `${ctx.index + 1}. `
          }
          return '- '
        },
        ctx,
      )
    },
  },
})
```

#### Signature

```typescript
function renderNestedMarkdownContent(
  node: JSONContent,
  helpers: {
    renderChildren: (nodes: JSONContent[]) => string
    indent: (text: string) => string
  },
  prefixOrGenerator: string | ((ctx: any) => string),
  ctx?: any,
): string
```

---

## Complete Examples

### Example 1: Callout Block

```typescript
import { Node } from '@tiptap/core'
import { createBlockMarkdownSpec } from '@tiptap/core'

export const Callout = Node.create({
  name: 'callout',
  group: 'block',
  content: 'block+',

  addAttributes() {
    return {
      type: { default: 'info' },
      title: { default: null },
    }
  },

  parseHTML() {
    return [{ tag: 'div[data-callout]' }]
  },

  renderHTML({ node }) {
    return [
      'div',
      {
        'data-callout': '',
        'data-type': node.attrs.type,
        'data-title': node.attrs.title,
      },
      0,
    ]
  },

  markdown: createBlockMarkdownSpec({
    nodeName: 'callout',
    defaultAttributes: { type: 'info' },
    allowedAttributes: ['type', 'title'],
  }),
})
```

**Markdown:**

```markdown
:::callout {type="warning" title="Watch out!"}
This is important information that needs attention.
:::
```

---

### Example 2: YouTube Embed

```typescript
import { Node } from '@tiptap/core'
import { createAtomBlockMarkdownSpec } from '@tiptap/core'

export const Youtube = Node.create({
  name: 'youtube',
  group: 'block',
  atom: true,

  addAttributes() {
    return {
      src: { default: null },
      start: { default: 0 },
    }
  },

  parseHTML() {
    return [{ tag: 'iframe[src*="youtube.com"]' }]
  },

  renderHTML({ node }) {
    return ['iframe', { src: node.attrs.src }]
  },

  markdown: createAtomBlockMarkdownSpec({
    nodeName: 'youtube',
    requiredAttributes: ['src'],
    allowedAttributes: ['src', 'start'],
  }),
})
```

**Markdown:**

```markdown
:::youtube {src="https://youtube.com/watch?v=dQw4w9WgXcQ" start="30"}
```

---

### Example 3: Mention (Inline)

```typescript
import { Node } from '@tiptap/core'
import { createInlineMarkdownSpec } from '@tiptap/core'

export const Mention = Node.create({
  name: 'mention',
  group: 'inline',
  inline: true,
  atom: true,

  addAttributes() {
    return {
      id: { default: null },
      label: { default: null },
    }
  },

  parseHTML() {
    return [{ tag: 'span[data-mention]' }]
  },

  renderHTML({ node }) {
    return ['span', { 'data-mention': node.attrs.id }, `@${node.attrs.label}`]
  },

  markdown: createInlineMarkdownSpec({
    nodeName: 'mention',
    selfClosing: true,
    allowedAttributes: ['id', 'label'],
  }),
})
```

**Markdown:**

```markdown
Hey [mention id="user123" label="John"], check this out!
```

---

## Comparison: Utilities vs Custom

### Using Utilities (Recommended for Standard Patterns)

```typescript
// ~10 lines of code
markdown: createBlockMarkdownSpec({
  nodeName: 'callout',
  defaultAttributes: { type: 'info' },
  allowedAttributes: ['type', 'title'],
})
```

### Custom Implementation (For Full Control)

```typescript
// ~50+ lines of code
markdown: {
  name: 'callout',

  tokenizer: {
    name: 'callout',
    level: 'block',
    start: (src) => src.indexOf(':::callout'),
    tokenize: (src, tokens, lexer) => {
      const match = /^:::callout(?:\s+\{([^}]*)\})?\s*\n([\s\S]*?)\n:::/.exec(src)
      if (!match) return undefined

      // Parse attributes
      const attrString = match[1] || ''
      const attributes = parseAttributes(attrString)

      // Parse content
      const content = match[2]
      const tokens = lexer.blockTokens(content)

      return {
        type: 'callout',
        raw: match[0],
        attributes,
        tokens,
      }
    },
  },

  parse: (token, helpers) => {
    return {
      type: 'callout',
      attrs: { ...{ type: 'info' }, ...token.attributes },
      content: helpers.parseChildren(token.tokens || []),
    }
  },

  render: (node, helpers) => {
    const attrs = node.attrs || {}
    const filteredAttrs = {
      type: attrs.type,
      title: attrs.title,
    }
    const attrString = serializeAttributes(filteredAttrs)
    const content = helpers.renderChildren(node.content || [])

    return `:::callout {${attrString}}\n${content}\n:::\n\n`
  },
}
```

## When to Use What

### Use Utilities When:

- ✅ Following standard markdown conventions (Pandoc, shortcodes)
- ✅ Standard attribute parsing is sufficient
- ✅ Block/inline distinction is clear
- ✅ Quick implementation is desired
- ✅ Maintaining consistency across extensions

### Use Custom Implementation When:

- ✅ Non-standard markdown syntax required
- ✅ Complex parsing logic needed
- ✅ Fine-grained control over tokens
- ✅ Custom attribute formats

---

## Related Documentation

- [Custom Tokenizers](./custom-tokenizers) - For custom syntax that doesn't follow conventions
- [Extension Integration](./extension-integration) - General guide to adding markdown to extensions
- [Advanced Customization](./advanced) - Custom parse and render handlers
- [API Reference](./api) - Complete API documentation

---

**Pro Tip**: Start with utilities for standard patterns, then move to custom implementations only when you need specific behavior that utilities don't provide.
