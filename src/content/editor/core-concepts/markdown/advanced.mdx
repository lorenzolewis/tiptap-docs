---
title: Advanced Usage
tags:
  - type: beta
meta:
  title: Markdown Advanced Usage | Tiptap Editor Docs
  description: Deep dive into customizing parse and render behavior with the Markdown extension in Tiptap. Learn about debugging, custom rules, and more.
  category: Editor
---

This guide covers advanced topics for customizing markdown parsing and serialization behavior in your Tiptap editor.

## Parsing Markdown content to Tiptap

Extensions can provide custom parsing logic to handle specific markdown tokens. This is done through the `markdown.parse` handler.

### Understanding Parse Handlers

A parse handler receives a markdown token from marked.js and returns Tiptap JSON content that can be consumed by the editor.
In addition to the token, the parse function also receives a `helpers` object with utility functions to assist in parsing.

These can be helpful for creating nodes, marks or parsing child `marked.js` tokens from `token.tokens`.

```typescript
markdown: {
  name: 'heading',  // Token type to handle
  parse: (token, helpers) => {
    return {
      type: 'heading',
      attrs: { level: token.depth },
      content: helpers.parseInline(token.tokens || []),
    }
  },
}
```

In this example the parse handler processes a `heading` token which is passed through by marked.js to our Markdown manager.
This token is picked up in this example and transformed into a Tiptap node with the node type `heading`.

The appropriate `level` attribute is extracted from the token and it's inline content (as headlines can only contain marks or inline text) are parsed using the `helpers.parseInline()` function.

**Important**: Attributes on tokens can vary depending on how the [Tokenizer](./introduction#tokenizer) is configured.

### Parse Helper Functions

As described in the section above, the `helpers` object provides utility functions for parsing child tokens or creating nodes and marks.
Let us go through each helper and see how they can be used.

#### `helpers.parseInline(tokens)`

This helper takes a list of tokens and **tries** to parse them as inline content (text nodes with marks).
It will not verify if the tokens are actually inline tokens so make sure to only pass inline tokens here.

The function returns `TiptapJSON[]` that can be used as the `content` of a Tiptap Node.

```typescript
parse: (token, helpers) => {
  const content = helpers.parseInline(token.tokens || [])

  return {
    type: 'paragraph',
    content,
  }
}
```

#### `helpers.parseChildren(tokens)`

Similar to `parseInline()`, but parses tokens as block-level content (e.g., list items, blockquotes, code blocks and more).
It will not verify if the tokens are actually block-level tokens so make sure to only pass block-level tokens here.

The function returns `TiptapJSON[]` that can be used as the `content` of a Tiptap Node.

```typescript
parse: (token, helpers) => {
  // Parse nested block content (e.g., list items)
  const content = helpers.parseChildren(token.tokens || [])

  return {
    type: 'blockquote',
    content,
  }
}
```

### Examples

#### Custom Heading Parser

Let's build a custom heading parser for a `customHeading` extension that will extract the heading level and also generate a unique ID for each heading.

```typescript
import { Node } from '@tiptap/core'

const CustomHeading = Node.create({
  name: 'customHeading',

  // ... other config

  markdown: {
    parse: (token, helpers) => {
      const level = token.depth || 1 // we can get the heading level from the token

      // Add custom attributes
      return {
        type: 'customHeading',
        attrs: {
          level,
          id: `heading-${Math.random()}`, // Generate ID
        },
        content: helpers.parseInline(token.tokens || []), // parse the inline content of the heading token
      }
    },
  },
})
```

#### Custom YouTube Embed Parser

Let's create a custom parser for a `youtube` token that turns the token into a `youtubeEmbed` node with the appropriate embed attributes.

```typescript
import { Node } from '@tiptap/core'

const YoutubeEmbed = Node.create({
  name: 'youtubeEmbed',
  atom: true, // this is a self-contained node

  // ... other config

  markdown: {
    parse: (token) => {
      // Those attributes are extracted from the youtube token
      // we assume that a custom tokenizer is providing these tokens
      // from the markdown syntax like: ![youtube](videoId?start=60&width=800&height=450)
      const videoId = token.videoId || ''
      const start = token.start || 0
      const width = token.width || 560
      const height = token.height || 315


      // Because this is an atom node, we don't require the helpers
      // to parse any children, as this node is self-contained.
      return {
        type: 'youtubeEmbed',
        attrs: {
          videoId,
          start,
          width,
          height,
        },
      }
    },
  },
})
```

## Serializing Tiptap Content to Markdown

Serializing Tiptap JSON content to markdown is done through the `markdown.render` handler.

### Understanding Render Handlers

The process of turning Tiptap JSON nodes into markdown strings is handled by the `render` function defined in the `markdown` config of an extension.

This function can range in complexity from a simple string return to more complex logic that takes into account the node's attributes, its children, nesting and the context in which it appears.

The following parameters are passed to the render function:

- `node`: The Tiptap JSON node to be serialized.
- `helpers`: An object containing utility functions to assist in rendering (see [Render Helper Functions](#render-helper-functions) for details).
- `context`: An object providing additional context about the node's position in the document tree (see [Render Context](#render-context) for details).

The returned value of the render function should be a string representing the markdown equivalent of the node that will be concatenated with other strings to form the complete markdown document.

```typescript
markdown: {
  render: (node, helpers) => {
    const content = helpers.renderChildren(node.content)
    return `# ${content}\n\n`
  },
}
```

### Render Helper Functions

As described above, the `helpers` object provides utility functions for rendering child nodes and formatting content.
Let us go through each helper and see how they can be used.

#### `helpers.renderChildren(nodes, separator)`

The `helpers.renderChildren` function will take a list of Tiptap JSON nodes and render each of them to a markdown string using their respective render handlers.

It accepts an optional `separator` parameter that can be used to join the rendered child nodes with a specific string (defaults to `''`).

```typescript
render: (node, helpers) => {
  // Render all children
  const content = helpers.renderChildren(node.content || [])

  return `> ${content}\n\n`
}
```

or with a custom separator:

```typescript
render: (node, helpers) => {
  // Join list items with newlines
  const items = helpers.renderChildren(node.content || [], '\n')

  return items + '\n\n'
}
```

#### `helpers.indent(content)`

The `helpers.indent(content)` function will add indentation to each line of the provided content string based on the current context level and the configured indentation style (spaces or tabs).

This is helpful for example when rendering nested structures like lists.

```typescript
render: (node, helpers) => {
  const content = helpers.renderChildren(node.content || [])

  return helpers.indent(content) // indent the rendered content based off the current context level
}
```

#### `helpers.wrapInBlock(prefix, content)`

The `helpers.wrapInBlock` function will wrap content with a prefix on each line which is useful for block-level elements like blockquotes or code blocks.

```typescript
render: (node, helpers) => {
  const content = helpers.renderChildren(node.content || [])

  // Add "> " to each line for blockquote
  return helpers.wrapInBlock('> ', content)
}
```

### Render Context

The third parameter to render handlers is a context object that holds information about the current node's position in the document tree, like index, level, parent type and custom metadata.

```typescript
render: (node, helpers, context) => {
  const lines = []

  lines.push(`I am the ${context.index}th child in my parent context.`) // zero-based index of this node in its parent
  lines.push(`My current nesting level is ${context.level}`) // current nesting level (increased by 1 for each parent that has `indenting: true`)
  lines.push(`My parent node type is ${context.parentType}`) // type of the parent node
  lines.push(`My custom metadata is ${JSON.stringify(context.meta)}`) // custom metadata that can be set by parent nodes

  return lines.join('\n')
}
```

### Examples

#### Custom Heading Renderer

```typescript
const CustomHeading = Node.create({
  name: 'customHeading',

  markdown: {
    render: (node, helpers, context) => {
      const level = node.attrs?.level || 1 // lets get the heading level from the node attributes
      const prefix = '#'.repeat(level) // now create the appropriate prefix based on the level
      const content = helpers.renderChildren(node.content || []) // render the inline content of the heading

      return `${prefix} ${content}\n\n` // we build the markdown string here based off the information we have
    },
  },
})
```

#### YouTube Embed Renderer

In this scenario we want to serialize a `youtubeEmbed` node back to a markdown string that could be parsed by our custom YouTube tokenizer.

For this example, the syntax will be `![youtube](videoId?start=60&width=800&height=450)`

```typescript
const YouTubeEmbed = Node.create({
  name: 'youtubeEmbed',

  markdown: {
    isBlock: true,
    render: (node, helpers) => {
      // we can extract the attributes from the node
      const videoId = node.attrs?.videoId || ''
      const start = node.attrs?.start || 0
      const width = node.attrs?.width || 800
      const height = node.attrs?.height || 450

      // and just pass the attributes to the markdown string
      return `![youtube](${videoId}?start=${start}&width=${width}&height=${height})\n\n`
    },
  },
})
```

#### Rendering list items with indentation

For this example we want to render a custom list node that contains list items, each list items syntax should look like `=> item`.

```typescript
const CustomList = Node.create({
  name: 'customList',

  // ...

  markdown: {
    isIndenting: true, // This tells the MarkdownManager that this node increases the nesting level

    render: (node, helpers, context) => {
      // We use a custom separator to join list items with newlines
      const items = helpers.renderChildren(node.content || [], '\n')

      return items
    },
  },
})

const CustomListItem = Node.create({
  name: 'customListItem',

  // ...

  markdown: {
    render: (node, helpers, context) => {
      // First we extract the first child of the list item as the content (the paragraph node)
      // and keep the rest of the children to manually render them afterwards
      const [content, ...children] = node.content
      const output = [`=> ${content}`]

      // now we just render the direct child content for now
      const mainContent = helpers.renderChildren(node.content || [])

      // now we need to go through the children and render them indented as well
      if (children && children.length > 0) {
        children.forEach((child) => {
          const childContent = helpers.renderChildren([child]) // render the child node - this also will recursively render its children
          if (childContent) {
            // split the lines of the child content and indent each line
            const indentedChild = childContent
              .split('\n')
              .map((line) => (line ? helpers.indent(line) : ''))
              .join('\n')
            output.push(indentedChild) // this will push the child with correct indentation for this level
          }
        })
      }

      return output.join('\n') // join all lines with newlines
    },
  },
})
```

Because this is very verbose, Tiptap exports a `renderNestedMarkdownContent()` helper from the `@tiptap/markdown` package that can be used to simplify this:

```typescript
import { Node } from '@tiptap/core'
import { renderNestedMarkdownContent } from '@tiptap/markdown'

const CustomListItem = Node.create({
  name: 'customListItem',

  // ...

  markdown: {
    render: (node, helpers, context) => {
      return renderNestedMarkdownContent(node, helpers, '=> ', context)
    },
  },
})
```

Read more on our [utilities](./utilities#rendernestedmarkdowncontent) page.

## Handling Marks (Inline Formatting)

Marks are handled differently because they wrap inline content:

### Parse Marks

Use `helpers.applyMark()` to apply a mark to content:

```typescript
const Bold = Mark.create({
  name: 'bold',

  markdown: {
    name: 'strong',
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || []) // parse the inline content inside the mark
      return helpers.applyMark('bold', content) // apply the 'bold' mark to the parsed content
    },
  },
})
```

### Render Marks

Marks render as nodes that wrap their content:

```typescript
const Bold = Mark.create({
  name: 'bold',

  markdown: {
    render: (node, helpers) => {
      const content = helpers.renderChildren(node) // directly render the node
      return `**${content}**` // and return your markup syntax
    },
  },
})
```

### Marks with Attributes

```typescript
const Link = Mark.create({
  name: 'link',

  markdown: {
    name: 'link',
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])

      // we can use the third argument to apply attributes to the mark
      return helpers.applyMark('link', content, {
        href: token.href,
        title: token.title || null,
      })
    },
    render: (node, helpers) => {
      const content = helpers.renderChildren(node)
      const href = node.attrs?.href || ''
      const title = node.attrs?.title

      if (title) {
        return `[${content}](${href} "${title}")`
      }
      return `[${content}](${href})`
    },
  },
})
```

## Advanced Indentation Control

The `isIndenting` flag tells the MarkdownManager that a node increases the nesting level:

```typescript
markdown: {
  isIndenting: true,
  render: (node, helpers, context) => {
    // Children will be rendered at context.level + 1 if helpers.indent() is used
    const children = helpers.renderChildren(node.content || [])
    return children
  },
}
```

This is important for proper indentation of nested lists and code blocks.

### Custom Indentation Logic

You can implement custom indentation:

```typescript
render: (node, helpers, context) => {
  const content = helpers.renderChildren(node.content || [])

  // Add custom indentation based on level
  const indent = '  '.repeat(context.level)
  const lines = content.split('\n')
  const indented = lines.map(line => indent + line).join('\n')

  return indented
}
```

## Parse and Render Names

Extensions can use different names for parsing and rendering:

```typescript
markdown: {
  parseName: 'strong',     // Match 'strong' tokens when parsing
  renderName: 'bold',      // Render when node type is 'bold'

  parse: (token, helpers) => { /* ... */ },
  render: (node, helpers) => { /* ... */ },
}
```

This is useful when:

- Markdown token names differ from your node names
- Multiple markdown tokens map to the same node type
- One node type can be serialized to multiple markdown formats

### Example: Multiple Token Types

```typescript
// Bold can be parsed from both 'strong' and 'em' (incorrectly marked)
const Bold = Mark.create({
  name: 'bold',

  markdown: {
    parseName: 'strong',
    renderName: 'bold',

    parse: (token, helpers) => {
      return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))
    },

    render: (node, helpers) => {
      return `**${helpers.renderChildren(node)}**`
    },
  },
})
```

## Fallback Parsing

If no extension handles a specific token type, the MarkdownManager provides fallback parsing for common tokens:

- `paragraph` → `{ type: 'paragraph' }`
- `heading` → `{ type: 'heading', attrs: { level } }`
- `text` → `{ type: 'text', text }`
- `html` → Parsed using extensions' `parseHTML` methods

You can override this by providing your own handler for these token types.

## HTML Parsing in Markdown

When markdown contains HTML, it's parsed using your extensions' existing `parseHTML` methods.

```markdown
# Regular Markdown

<custom-component data-foo="bar">
  <p>This HTML is parsed by your extensions</p>
</custom-component>

More **markdown** here.
```

## Debugging Parse and Render

### Debug Parsing

Log tokens to understand what marked.js produces:

```typescript
const markdown = '# Hello **World**'
const tokens = editor.markdown.instance.lexer(markdown)
console.log(JSON.stringify(tokens, null, 2))
```

### Debug Serialization

Log the JSON structure before serialization:

```typescript
const json = editor.getJSON()
console.log(JSON.stringify(json, null, 2))

const markdown = editor.markdown.serialize(json)
console.log(markdown)
```

### Test Individual Handlers

Test your handlers in isolation:

```typescript
// Test parsing
const token = {
  type: 'heading',
  depth: 1,
  tokens: [{ type: 'text', text: 'Hello' }],
}

const helpers = {
  parseInline: tokens => [{ type: 'text', text: 'Hello' }],
  // ... other helpers
}

const result = myExtension.options.markdown.parse(token, helpers)
console.log(result)

// Test rendering
const node = {
  type: 'heading',
  attrs: { level: 1 },
  content: [{ type: 'text', text: 'Hello' }],
}

const renderHelpers = {
  renderChildren: nodes => 'Hello',
  // ... other helpers
}

const markdown = myExtension.options.markdown.render(node, renderHelpers, {})
console.log(markdown)
```

## Performance Considerations

### Lazy Parsing

For large documents, consider parsing on demand:

```typescript
let cachedJSON = null

function getJSON() {
  if (!cachedJSON) {
    cachedJSON = editor.markdown.parse(largeMarkdownString)
  }
  return cachedJSON
}
```

### Incremental Updates

Instead of re-parsing the entire document on each change, update specific sections:

```typescript
editor.commands.insertContentAt(position, newMarkdown, { asMarkdown: true })
```

### Caching Serialization

Cache markdown serialization results:

```typescript
let markdownCache = null
let lastJSON = null

editor.on('update', () => {
  markdownCache = null // Invalidate cache
})

function getMarkdown() {
  const currentJSON = editor.getJSON()

  if (markdownCache && JSON.stringify(lastJSON) === JSON.stringify(currentJSON)) {
    return markdownCache
  }

  lastJSON = currentJSON
  markdownCache = editor.getMarkdown()
  return markdownCache
}
```

## Next Steps

- Learn how to create [Custom Tokenizers](./custom-tokenizers) for non-standard markdown syntax
- See how to [integrate markdown support into your extensions](./extension-integration)
- Check out the [API Reference](./api) for complete documentation
- Explore [Examples](./examples) for common use cases