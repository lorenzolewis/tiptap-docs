---
title: Markdown Examples
tags:
  - type: beta
meta:
  title: Markdown Examples | Tiptap Editor Docs
  description: Explore practical examples of using the Markdown extension in Tiptap. Learn how to parse, serialize, and customize markdown content in your editor.
  category: Editor
---

Real-world examples and recipes for common use cases with the Markdown extension.

## Basic Examples

### Read and Write Markdown

This example demonstrates the most common markdown operations:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'

const editor = new Editor({
  element: document.querySelector('#editor'),
  extensions: [StarterKit, Markdown],
  content: '# Hello World\n\nStart typing...',
  contentAsMarkdown: true, // parse initial content as markdown
})

// Read: serialize current editor content to Markdown
console.log(editor.getMarkdown())

// Write: set editor content from a Markdown string
editor.commands.setContent('# New title\n\nSome *markdown* content', { asMarkdown: true })
```

---

### Paste Markdown Detection

Automatically detect and parse pasted markdown:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'
import { Plugin } from '@tiptap/pm/state'

const PasteMarkdown = Extension.create({
  name: 'pasteMarkdown',

  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handlePaste(view, event, slice) {
            const text = event.clipboardData?.getData('text/plain')

            if (!text) {
              return false
            }

            // Check if text looks like markdown
            if (looksLikeMarkdown(text)) {
              const { state, dispatch } = view
              // Parse the markdown text to Tiptap JSON using the markdown manager
              const json = editor.markdown.parse(text)

              // Insert the parsed JSON content at cursor position
              editor.commands.insertContent(json)
              return true
            }

            return false
          },
        },
      }),
    ]
  },
})

function looksLikeMarkdown(text: string): boolean {
  // Simple heuristic: check for markdown syntax
  return (
    /^#{1,6}\s/.test(text) || // Headings
    /\*\*[^*]+\*\*/.test(text) || // Bold
    /\[.+\]\(.+\)/.test(text) || // Links
    /^[-*+]\s/.test(text)
  ) // Lists
}

const editor = new Editor({
  extensions: [StarterKit, Markdown, PasteMarkdown],
})
```

---

## Custom Extensions

### Highlight Mark

Add a custom highlight mark with `==syntax==`:

```typescript
import { Mark } from '@tiptap/core'

export const Highlight = Mark.create({
  name: 'highlight',

  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },

  parseHTML() {
    return [{ tag: 'mark' }]
  },

  renderHTML({ HTMLAttributes }) {
    return ['mark', HTMLAttributes, 0]
  },

  markdown: {
    name: 'highlight',

    // Custom tokenizer to recognize ==text== syntax
    tokenizer: {
      name: 'highlight',
      level: 'inline', // This is an inline element
      start: (src) => src.indexOf('=='), // Optimize: where to start looking
      tokenize: (src, tokens, lexer) => {
        // Match ==text== at the start of the remaining source
        const match = /^==([^=]+)==/.exec(src)
        if (!match) return undefined

        return {
          type: 'highlight', // Token type (matches markdown.name)
          raw: match[0], // Full matched string: ==text==
          text: match[1], // Content inside: text
          tokens: lexer.inlineTokens(match[1]), // Parse nested inline formatting
        }
      },
    },

    // Parse markdown token to Tiptap JSON
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])
      // Apply the 'highlight' mark to the parsed content
      return helpers.applyMark('highlight', content)
    },

    // Render Tiptap node back to markdown
    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `==${content}==` // Wrap content in == syntax
    },
  },

  addCommands() {
    return {
      toggleHighlight:
        () =>
        ({ commands }) => {
          return commands.toggleMark(this.name)
        },
    }
  },
})
```

Usage:

```typescript
const editor = new Editor({
  extensions: [StarterKit, Markdown, Highlight],
})

editor.commands.setContent('This is ==highlighted== text', { asMarkdown: true })
```

---

### Admonition Block

Create admonition blocks with `:::type` syntax:

```typescript
import { Node } from '@tiptap/core'

export const Admonition = Node.create({
  name: 'admonition',

  group: 'block',
  content: 'block+',
  defining: true,

  addOptions() {
    return {
      types: ['note', 'warning', 'tip', 'danger'],
    }
  },

  addAttributes() {
    return {
      type: {
        default: 'note',
        parseHTML: (element) => element.getAttribute('data-type'),
        renderHTML: (attributes) => ({
          'data-type': attributes.type,
        }),
      },
    }
  },

  parseHTML() {
    return [{ tag: 'div[data-admonition]' }]
  },

  renderHTML({ node, HTMLAttributes }) {
    return ['div', { 'data-admonition': '', ...HTMLAttributes }, 0]
  },

  markdown: {
    name: 'admonition',

    // Custom tokenizer for :::type...:::  block syntax
    tokenizer: {
      name: 'admonition',
      level: 'block', // This is a block-level element
      start: (src) => src.indexOf(':::'),
      tokenize: (src, tokens, lexer) => {
        // Match :::type\ncontent\n::: pattern
        const match = /^:::(\w+)\n([\s\S]*?)\n:::/.exec(src)
        if (!match) return undefined

        return {
          type: 'admonition',
          raw: match[0], // Full matched string
          admonitionType: match[1], // The type (note, warning, etc.)
          text: match[2], // Content inside
          tokens: lexer.blockTokens(match[2]), // Parse nested block content
        }
      },
    },

    // Parse markdown token to Tiptap JSON
    parse: (token, helpers) => {
      return {
        type: 'admonition',
        attrs: { type: token.admonitionType || 'note' }, // Store type as attribute
        content: helpers.parseChildren(token.tokens || []), // Parse nested blocks
      }
    },

    // Render Tiptap node back to markdown
    render: (node, helpers) => {
      const type = node.attrs?.type || 'note'
      const content = helpers.renderChildren(node.content || [])
      return `:::${type}\n${content}:::\n\n` // Reconstruct :::type...:::
    },
  },
})
```

Usage:

```typescript
const markdown = `
:::warning
This is a warning message with **bold** text.
:::
`

editor.commands.setContent(markdown, { asMarkdown: true })
```

---

### Emoji Shortcode

Support emoji shortcodes like `:smile:`:

```typescript
import { Node } from '@tiptap/core'

const emojiMap = {
  smile: '😊',
  heart: '❤️',
  thumbsup: '👍',
  fire: '🔥',
  // ... add more
}

export const Emoji = Node.create({
  name: 'emoji',

  group: 'inline',
  inline: true,
  atom: true,

  addAttributes() {
    return {
      name: { default: null },
    }
  },

  parseHTML() {
    return [{ tag: 'span[data-emoji]' }]
  },

  renderHTML({ node }) {
    const emoji = emojiMap[node.attrs.name] || node.attrs.name
    return ['span', { 'data-emoji': node.attrs.name }, emoji]
  },

  markdown: {
    name: 'emoji',

    // Custom tokenizer for :emoji: shortcode syntax
    tokenizer: {
      name: 'emoji',
      level: 'inline',
      start: (src) => src.indexOf(':'),
      tokenize: (src, tokens, lexer) => {
        // Match :name: pattern (e.g., :smile:, :heart:)
        const match = /^:([a-z0-9_+]+):/.exec(src)
        if (!match) return undefined

        return {
          type: 'emoji',
          raw: match[0], // Full match: :smile:
          emojiName: match[1], // Emoji name: smile
        }
      },
    },

    // Parse token to Tiptap JSON (emoji is an atomic node)
    parse: (token, helpers) => {
      return {
        type: 'emoji',
        attrs: { name: token.emojiName }, // Store emoji name
      }
    },

    // Render node back to :emoji: syntax
    render: (node, helpers) => {
      return `:${node.attrs?.name || 'unknown'}:`
    },
  },
})
```

Usage:

```typescript
editor.commands.setContent('Hello :smile: :heart: :thumbsup:', { asMarkdown: true })
```

---

## Custom Tokenizers

### Subscript and Superscript

Support `~subscript~` and `^superscript^`:

```typescript
import { Mark } from '@tiptap/core'

export const Subscript = Mark.create({
  name: 'subscript',

  parseHTML() {
    return [{ tag: 'sub' }]
  },

  renderHTML() {
    return ['sub', 0]
  },

  markdown: {
    name: 'subscript',

    // Custom tokenizer for ~text~ subscript syntax
    tokenizer: {
      name: 'subscript',
      level: 'inline',
      start: (src) => src.indexOf('~'),
      tokenize: (src, tokens, lexer) => {
        const match = /^~([^~]+)~/.exec(src)
        if (!match) return undefined

        return {
          type: 'subscript',
          raw: match[0], // Full match: ~text~
          text: match[1], // Content: text
          tokens: lexer.inlineTokens(match[1]), // Parse nested inline formatting
        }
      },
    },

    // Parse token and apply subscript mark to content
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])
      return helpers.applyMark('subscript', content)
    },

    // Render back to ~text~ syntax
    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `~${content}~`
    },
  },
})

export const Superscript = Mark.create({
  name: 'superscript',

  parseHTML() {
    return [{ tag: 'sup' }]
  },

  renderHTML() {
    return ['sup', 0]
  },

  markdown: {
    name: 'superscript',

    // Custom tokenizer for ^text^ superscript syntax
    tokenizer: {
      name: 'superscript',
      level: 'inline',
      start: (src) => src.indexOf('^'),
      tokenize: (src, tokens, lexer) => {
        const match = /^\^([^^]+)\^/.exec(src)
        if (!match) return undefined

        return {
          type: 'superscript',
          raw: match[0], // Full match: ^text^
          text: match[1], // Content: text
          tokens: lexer.inlineTokens(match[1]), // Parse nested inline formatting
        }
      },
    },

    // Parse token and apply superscript mark to content
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])
      return helpers.applyMark('superscript', content)
    },

    // Render back to ^text^ syntax
    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `^${content}^`
    },
  },
})
```

Usage:

```typescript
editor.commands.setContent('H~2~O and E = mc^2^', { asMarkdown: true })
```

## Integration Examples

### Real-Time Markdown Preview

You can create a real-time markdown preview by listening to editor updates:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'

const editor = new Editor({
  extensions: [StarterKit, Markdown],
  content: '# Hello',
  onUpdate: ({ editor }) => {
    const markdown = editor.getMarkdown()
    updatePreview(markdown) // Your preview update function
  },
})

function updatePreview(markdown) {
  document.querySelector('#preview').textContent = markdown
}
```

### Saving and Loading Workflow

Store content as markdown and load it when needed:

```typescript
// Save to database/storage
async function saveContent() {
  const markdown = editor.getMarkdown()
  await fetch('/api/save', {
    method: 'POST',
    body: JSON.stringify({ content: markdown }),
  })
}

// Load from database/storage
async function loadContent() {
  const { content } = await fetch('/api/load').then((r) => r.json())
  editor.commands.setContent(content, { asMarkdown: true })
}
```

## Server-Side Rendering

Render markdown on the server:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'
import { generateHTML } from '@tiptap/html'

// Parse markdown to JSON on server
function parseMarkdown(markdown: string) {
  const editor = new Editor({
    extensions: [StarterKit, Markdown], // Include Markdown extension
  })

  // Use the markdown manager to parse markdown string to JSON
  const json = editor.markdown.parse(markdown)
  editor.destroy()

  return json
}

// Convert JSON to HTML for rendering
function renderToHTML(json: JSONContent) {
  // Generate HTML from Tiptap JSON (no markdown involved here)
  return generateHTML(json, [StarterKit])
}

// Full pipeline: Markdown → JSON → HTML
function markdownToHTML(markdown: string) {
  const json = parseMarkdown(markdown) // Parse markdown to JSON
  return renderToHTML(json) // Render JSON to HTML
}

// Express route example
app.get('/document/:id', async (req, res) => {
  const doc = await db.getDocument(req.params.id)
  const json = parseMarkdown(doc.markdown) // Parse stored markdown
  const html = renderToHTML(json) // Convert to HTML for display

  res.render('document', { content: html })
})
```

---

## Advanced Patterns

### Lazy Loading Large Documents

Load large documents progressively:

```typescript
async function loadLargeDocument(documentId: string) {
  // Load metadata first
  const meta = await fetchDocumentMeta(documentId)

  // Show skeleton
  showSkeleton()

  // Load in chunks
  const chunks = await fetchDocumentChunks(documentId, meta.chunkCount)

  // Parse each markdown chunk and insert at correct position
  for (const chunk of chunks) {
    const json = editor.markdown.parse(chunk.markdown) // Parse markdown to JSON
    editor.commands.insertContentAt(chunk.position, json) // Insert at position
  }

  hideSkeleton()
}
```

---

## See Also

- [Installation](./installation)
- [Basic Usage](./basic-usage)
- [Advanced Customization](./advanced-usage)
- [Custom Tokenizers](./custom-tokenizers)
- [Extension Integration](./extension-integration)
- [API Reference](./api)
